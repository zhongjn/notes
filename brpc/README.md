# brpc

## epoll

1. 使用 edge trigger + 非阻塞 fd（阻塞时返回 EAGAIN）
2. 原子性事件计数器来协调驱动线程（epoll_wait 的调用者）、处理线程
   - 收到事件时计数器原子自增1，如果之前为0启动处理线程
   - 处理线程不断读取 fd，若 fd 返回 EAGAIN，检查事件计数器是否变化，没有则退出（认为 fd 静默）
   - 优点：静默的 fd 不需要对应的处理线程（即使挂起），内存占用小

## socket

1. 消息处理线程类似 epoll 中的处理线程
2. 消息写使用 wait free queue
   - 写入时，当前新增节点 next 设置为特殊值（UNCONNECTED），exchange 头节点，将当前节点 next 设置为原头节点
   - 读取时，翻转上次读取头、最新头之间的所有链表节点（使其符合链表队列顺序，即 next 指向排在队伍后面的元素）
   - 快路径是写不被阻塞（不返回 EAGAIN）且结束时没有发现更多写请求，可以在当前线程执行；否则为慢路径，单独开一个写线程
3. socket 需要生命周期管理，epoll 的 fd 需要关联一个 socket，难点是在 epoll_wait 返回时检测 socket 是否已经失效（data 字段需要存储什么）
   - 构造不出引用计数的方案
   - brpc 方案：带版本号的指针，指向内容永不释放（对象池中），指针版本号与实际版本号比较
   - 可能方案：使用 ebr，epoll_wait（附带超时）在读临界区内，保证 data 指针有效

## doubly buffered data

对于读多写极少场景，一份前台数据负责读，一份后台数据负责写，写后交换。如何同步读写？本质：写者等待所有当前的读临界区退出。

- brpc 方案：读临界区持有线程本地锁，写入时获取、释放一遍全部线程本地锁。实现简单，等待久
- 可能方案：left-right 中的 epoch，等待所有在读临界区的线程的 epoch 增加
